
В DataSpace можно использовать *строковые выражения*, которые позволяют моделировать выражения различных уровней сложности.

Поддерживаются следующие типы следующие типы строковых выражений:

* *примитивное выражение*;
* *коллекция примитивных выражений*;
* *сущность*;
* *коллекция сущностей*;
* *условие*.

# Базовые объекты

В грамматике строковых выражений предусмотрены следующие базовые объекты:

* [корневая сущность][201];
* [элемент коллекции][202];
* [текущий элемент][203];
* [сущность под псевдонимом][204];
* [сущности][205];
* [примитивное значение][206].

## Корневая сущность

Корневая сущность имеет тип *сущность*, обозначается с помощью ключевого слова `root` и имеет следующие настройки
[спецификации][207]:

* `type` - тип сущности - позволяет уточнить тип сущности для обращения к свойствам типа-наследника.

Корневую сущность можно, например, использовать для обращения к искомой сущности при поиске.

---

**Пример 1**

*Условие*: код продукта соответствует шаблону 'product%' (при поиске продуктов).

```
root.code $like 'product%'
```

---

**Пример 2**

*Примитивное значение*: ставка депозита больше 10 (при поиске продуктов).

```
root{type = Deposit}.rate > 10
```

---

> Рекомендуется для обращению к корневой сущности использовать [текущий элемент][203] в ситуациях, когда в контексте они
> обозначают один и тот же объект.

## Элемент коллекции

Элемент коллекции имеет тип *сущность* или *примитивное выражение* в зависимости от контекста. Обозначается с помощью
ключевого слова `elem`. В случае, если имеет тип *сущность*, то имеет следующие настройки [спецификации][207]:
* `type` - тип сущности - позволяет уточнить тип сущности-элемента для обращения к свойствам типа-наследника.

Элемент коллекции можно использовать в поисках для обращения к элементу коллекции при фильтрации коллекции.

---

**Пример 1**

*Условие*: код сервиса начинается с кода продукта (при запросе сервисов при поиске продуктов).

```
elem.code $like root.code + '%'
```

---

**Пример 2**

*Условие*: состояние начинается с символа 'a' (при запросе состояний при поиске продуктов).

```
elem $like 'a%'
```

---

> Рекомендуется для обращения к элементу коллекции использовать [текущий элемент][203].

## Текущий элемент

Текущий элемент имеет тип *сущность* или *примитивное значение* в зависимости от контекста. Обозначается с помощью
ключевого слова `it`. В случае, если имеет тип *сущность*, то имеет следующие настройки [спецификации][207]:
* `type` - тип сущности - позволяет уточнить тип сущности-элемента для обращения к свойствам типа-наследника.

Текущий элемент используется для обращения к текущему рассматриваемому элементу выражения.
Например, в случае условия поиска текущий элемент является эквивалентом [корневой сущности][201], а в случае фильтрации
коллекции - [элемента коллекции][202].

---

**Пример 1**

*Условие*: код продукта соответствует шаблону 'product%' (при поиске продуктов).

```
it.code $like 'product%'
```

---

**Пример 2**

*Условие*: код сервиса начинается с кода продукта (при запросе сервисов при поиске продуктов).

```
it.code $like root.code + '%'
```

---

## Сущность под псевдонимом

Если в контексте присутствуют сущности под псевдонимом, то к ним можно обратиться через ключевое слово `@` с последующим указением псевдонима.

При обращении к сущности под псевдонимом можно использовать следующие настройки [спецификации][207]:

* `type` - тип сущности. Параметр позволяет уточнить тип сущности для обращения к свойствам типа-наследника.

---

**Пример**

*Условие*: код продукта под псевдонимом 'product' равен 'product1' (при запросе сервисов у запрощенных продуктов
при поиске документов).

```
@product.code == 'product1'
```

---

## Сущности

Сущности имеют тип *коллекция сущностей*, обозначаются с помощью ключевого слова `entities` и имеют следующие настройки
[спецификации][207]:

* `type` - тип сущностей (обязательная настройка);
* `elemAlias` - псевдоним элемента;
* `cond` - условие фильтрации сущностей;

---

**Пример**

*Условие*: существуют контракты, код которых равен коду продукта (при поиске продуктов).

```
entities{type = Contract, cond = it.code == root.code}.$exists
```

---

## Примитивное значение

Имеется возможность задать базовые *примитивные выражения*:

Тип | Формат | Пример значения
--- | ------ | ---------------
Строка | Строка, обрамленная одинарными кавычками (`'`). Для обозначения одинарной кавычки необходимо написать одинарную кавычку два раза подряд (`''`) | `'I''m a string'`
Целое число | | `123`
Вещественное число | Целая и вещественная часть отделены точкой. Использовние [экспоненциальной записи][208] не допускается | `123.456`
Дата | [ISO 8601][209] с префиксом `D` | `D2021-04-12`
Дата и время | [ISO 8601][209] с префиксом `D` | `D2021-04-12T13:18:10.123`
Дата и время со смещением | [ISO 8601][209] с префиксом `D` | `D2021-04-12T13:18:10.123+03:00`
Логическое значение | | `true` или `false`

# Спецификация

Некоторые объекты могут иметь дополнительные настройки. Например, `type` для [корневой сущности][201].
Для задания данных настроек вводится понятие спецификации.

Спецификацию для объекта можно указать в фигурных скобках (`{` и `}`), а настройки указываются следующим образом:

```
${наименование настройки} = ${значение настройки}`
```

- и перечисляются через запятую.

---

**Пример**

*Коллекция сущностей*: продукты, код которых соответствует шаблону 'product%'.

```
entities{type = Product, cond = it.code $like 'product%'}
```

---

# Методы выражений

Каждый тип выражения предоставляет набор методов, которые можно использовать при описании выражения.

## Методы примитивных выражений

Для *примитивных выражений* доступны следующие методы:

* отрицание: `-${примитивное выражение}` (**Пример**: `-it.number`);
* приведение в верхний регистр: `${примитивное выражение}.$upper` (**Пример**: `it.string.$upper`);
* приведение в нижний регистр: `${примитивное выражение}.$lower` (**Пример**: `it.string.$lower`);
* длина: `${примитивное выражение}.$length` (**Пример**: `it.string.$length`);
* отсечение пробельных символов в начале и конце: `${примитивное выражение}.$trim` (**Пример**: `it.string.$trim`);
* отсечение пробельных символов в начале: `${примитивное выражение}.$ltrim` (**Пример**: `it.string.$ltrim`);
* отсечение пробельных символов в конце: `${примитивное выражение}.$rtrim` (**Пример**: `it.string.$rtrim`);
* округление: `${примитивное выражение}.$round` (**Пример**: `it.number.$round`);
* округление вверх: `${примитивное выражение}.$ceil` (**Пример**: `it.number.$ceil`);
* округление вниз: `${примитивное выражение}.$floor` (**Пример**: `it.number.$floor`);
* хеш: `${примитивное выржение}.$hash` (**Пример**: `it.string.$hash`);
* приведение к строке: `${примитивное выржение}.$asString` (**Пример**: `it.number.$asString`);
* приведение к большому десятичному числу: `${примитивное выржение}.$asBigDecimal` (**Пример**: `it.string.$asBigDecimal`);
* модуль числа: `${примитивное выржение}.$abs` (**Пример**: `it.string.$abs`);
* сложение: `${примитивное выражение} + ${примитивное выражение}` (**Пример**: `it.number + 4`);
* разность: `${примитивное выражение} - ${примитивное выражение}` (**Пример**: `it.number - 4`);
* произведение: `${примитивное выражение} * ${примитивное выражение}` (**Пример**: `it.number * 4`);
* деление: `${примитивное выражение} / ${примитивное выражение}` (**Пример**: `it.number / 4`);
* подстрока: `${примитивное выражение}.$substr(${примитивное выражение (индекс начала)})` (**Пример**: `it.string.$substr(4)`);
* подстрока: `${примитивное выражение}.$substr(${примитивное выражение (индекс начала)}, ${примитивное выражение (длина)})` (**Пример**: `it.string.$substr(4, it.number)`);
* замена: `${примитивное выражение}.$replace(${примитивное выражение (заменяемая строка)}, ${примитивное выражение (новая строка)})` (**Пример**: `it.string.$replace('code', it.name)`);
* добавление милисекунд: `${примитивное выражение}.$addMilliseconds(${примитивное выражение})` (**Пример**: `it.date.$addMilliseconds(1)`);
* добавление секунд: `${примитивное выражение}.$addSeconds(${примитивное выражение})` (**Пример**: `it.date.$addSeconds(1)`);
* добавление минут: `${примитивное выражение}.$addMinutes(${примитивное выражение})` (**Пример**: `it.date.$addMinutes(1)`);
* добавление часов: `${примитивное выражение}.$addHours(${примитивное выражение})` (**Пример**: `it.date.$addHours(1)`);
* добавление дней: `${примитивное выражение}.$addDays(${примитивное выражение})` (**Пример**: `it.date.$addDays(1)`);
* добавление месяцев: `${примитивное выражение}.$addMonths(${примитивное выражение})` (**Пример**: `it.date.$addMonths(1)`);
* добавление годов: `${примитивное выражение}.$addYears(${примитивное выражение})` (**Пример**: `it.date.$addYears(1)`);
* вычитание милисекунд: `${примитивное выражение}.$subMilliseconds(${примитивное выражение})` (**Пример**: `it.date.$subMilliseconds(1)`);
* вычитание секунд: `${примитивное выражение}.$subSeconds(${примитивное выражение})` (**Пример**: `it.date.$subSeconds(1)`);
* вычитание минут: `${примитивное выражение}.$subMinutes(${примитивное выражение})` (**Пример**: `it.date.$subMinutes(1)`);
* вычитание часов: `${примитивное выражение}.$subHours(${примитивное выражение})` (**Пример**: `it.date.$subHours(1)`);
* вычитание дней: `${примитивное выражение}.$subDays(${примитивное выражение})` (**Пример**: `it.date.$subDays(1)`);
* вычитание месяцев: `${примитивное выражение}.$subMonths(${примитивное выражение})` (**Пример**: `it.date.$subMonths(1)`);
* вычитание годов: `${примитивное выражение}.$subYears(${примитивное выражение})` (**Пример**: `it.date.$subYears(1)`);
* условие "Равен null": `${примитивное выражение} == null` (**Пример**: `it.code == null`);
* условие "Не равен null": `${примитивное выражение} != null` (**Пример**: `it.code != null`);
* условие "Равен": `${примитивное выражение} == ${примитивное выражение}` (**Пример**: `it.code == 'service'`);
* условие "Не равен": `${примитивное выражение} != ${примитивное выражение}` (**Пример**: `it.code != 'service'`);
* условие "Больше": `${примитивное выражение} > ${примитивное выражение}` (**Пример**: `it.number > 4`);
* условие "Меньше или равно": `${примитивное выражение} <= ${примитивное выражение}` (**Пример**: `it.number <= 4`);
* условие "Меньше": `${примитивное выражение} < ${примитивное выражение}` (**Пример**: `it.number < 4`);
* условие "Подобен": `${примитивное выражение} $like ${примитивное выражение}` (**Пример**: `it.code $like 'service%'`);
* условие "Между": `${примитивное выражение} $between (${примитивное выражение}, ${примитивное значение})` (**Пример**: `it.number $between (4, it.number2)`);
* условие "В": `${примитивное выражение} $in [${примитивное выражение}, ...]` (**Пример**: `it.number $in [4, it.number2, 6]`);
* условие "В": `${примитивное выражение} $in ${коллекция примитивных значений}` (**Пример**: `it.number $in it.numbers`).

## Методы коллекций примитивных выражений

Для *коллекций примитивных выражений* доступны следующие методы:
* минимум: `${коллекция примитивных значений}.$min` (**Пример**: `it.numbers.$min`);
* максимум: `${коллекция примитивных значений}.$max` (**Пример**: `it.numbers.$max`);
* сумма: `${коллекция примитивных значений}.$sum` (**Пример**: `it.numbers.$sum`);
* среднее: `${коллекция примитивных значений}.$avg` (**Пример**: `it.numbers.$avg`);
* количество элементов: `${коллекция примитивных значений}.$count` (**Пример**: `it.numbers.$count`);
* условие "Существует": `${коллекция примитивных значений}.$exists` (**Пример**: `it.numbers.$exists`).

## Методы сущностей

Для *сущностей* доступны следующие методы:

* тип: `${сущность}.$type` (**Пример**: `it.$type`);
* id: `${сущность}.$id` (**Пример**: `it.$id`);
* примитив: `${сущность}.${наименование свойства}` (**Пример**: `it.code`);
* коллекция примитивов: `${сущность}.${наименование свойства}${спецификация}` (**Пример**: `it.states`, `it.states{cond = it $like 'h%'}`).
  Доступные настройки [спецификации][207]:
    * `cond` - условие - условие фильтрации;
* ссылка: `${сущность}.${наименование свойства}${спецификация}` (**Пример**: `it.product`, `it.product{type = Deposit}`).
  Доступные настройки [спецификации][207]:
    * `type` - тип сущности - позволяет уточнить тип сущности для обращения к свойствам типа-наследника;
    * `alias` - псевдоним - позволяет сохранить ссылку под псевдонимом в контекст;
* коллекция ссылок: `${сущность}.${наименование свойства}${спецификация}` (**Пример**: `it.services`, `it.services{type = SuperService, cond = it.code like root.code + 'service%'}`, `it.services{elemAlias = service, cond = it.parameters{cond = it.code == @service.code}.$exists}.$exists`).
  Доступные настройки [спецификации][207]:
    * `type` - тип сущности - позволяет ограничить коллекцию до коллекции, ссылки которой указывают на сущность указанного типа;
    * `elemAlias` - псевдоним элемента - позволяет сохранить ссылку из коллекции под псевдонимом в контекст;
    * `cond` - условие - условие фильтрации;
* условие "Равен null": `${сущность} == null` (**Пример**: `it.product == null`);
* условие "Не равен null": `${сущность} != null` (**Пример**: `it.product != null`);
* условие "Существует": `${сущность}.$exists` (**Пример**: `it.product.$exists`);
* условие "Равно": `${сущность} == ${сущность}` (**Пример**: `it.product == it.document.product`);
* условие "Не равно": `${сущность} != ${сущность}` (**Пример**: `it.product != it.document.product`);
* условие "В": `${сущность} $in [${сущность}, ...]` (**Пример**: `it.product $in [it.document.product, it.document.relatedProduct]`);
* условие "В": `${сущность} $in ${коллекция сущностей}` (**Пример**: `it.product $in it.services.product`).

## Методы коллекций сущностей

Для *коллекций сущностей* доступны следующие методы:

* коллекция примитивных выражений на основе типа сущности: `${коллекция сущностей}.$type` (**Пример**: `it.services.$type`);
* коллекция примитивных выражений на основе id сущности: `${коллекция сущностей}.$id` (**Пример**: `it.services.$id`);
* коллекция примитивных выражений на основе примитива: `${коллекция сущностей}.${наименование свойства}` (**Пример**: `it.services.code`);
* коллекция сущностей на основе ссылки: `${коллекция сущностей}.${наименование свойства}${спецификация}` (**Пример**: `it.services.product`, `it.services.product{type = Deposit}`).
  Доступные настройки [спецификации][207]:
    * `type` - тип сущности - позволяет ограничить коллекцию до коллекции, ссылки которой указывают на сущность указанного типа;
* количество элементов: `${коллекция сущностей}.$count` (**Пример**: `it.services.$count`);
* условие "Существует": `${коллекция сущностей}.$exists` (**Пример**: `it.services.$exists`).

## Методы условий

Для *условий* доступны следующие методы:
* условие "Отрицание": `!${условие}` (**Пример**: `!it.services.$exists`);
* условие "И": `${условие} && ${условие}` (**Пример**: `it.services.$exists && it.product != null`);
* условие "Или": `${условие} || ${условие}` (**Пример**: `it.services.$exists || it.product != null`).

## Общие методы

Доступны следующие общие методы:
* первый ненулевой элемент: `coalesce(${примитивное выражение}, ...)` (**Пример**: `coalesce(it.string, it.string2)`).

# Примеры

---

**Пример 1**

*Условие*: код продукта равен 'product1' независимо от регистра (при поиске продуктов).

```
it.code.$lower == 'product1'
```

---

**Пример 2**

*Условие*: суммарное время выполнение всех сервисов продукта, код которых начинается с кода продукта, не превышает 10
(при поиске продуктов).

```
it.services{cond = it.code $like root.code + '%'}.executionTime.$sum <= 10
```

---


[201]: #корневая-сущность "Корневая сущность"
[202]: #элемент-коллекции "Элемент коллекции"
[203]: #текущий-элемент "Текущий элемент"
[204]: #сущность-под-псевдонимом "Сущность под псевдонимом"
[205]: #сущности "Сущности"
[206]: #примитивное-значение "Примитивное значение"
[207]: #спецификация "Спецификация"
[208]: https://ru.wikipedia.org/wiki/Экспоненциальная_запись "Экспоненциальная запись"
[209]: https://ru.wikipedia.org/wiki/ISO_8601 "ISO 8601"